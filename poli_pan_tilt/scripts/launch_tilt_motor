#!/usr/bin/env python

"""
This is a high level driver for the EPOS tilt controller for the PoliV2 platform.
This file also launches a script that moves the pan/tilt/pillar/led systems for visual inspection.

The specific purpose of this driver is to ensure that the tilt motor's position encoders 
have been initialized properly. The encoders are set on power-on to the motor.

This driver checks if the tilt LIMIT SWITCH is pressed.
If so, it launches the tilt driver and checks the reported position of its encoders.
If its position value reports 0.0 +/- TOLERANCE the driver is kept alive.
If its out of TOLERANCE the driver is killed, error messages are logged, and this driver exits.

There is a persistance parameter INIT_PARAM that is used to track if this driver has been run since 
the robot has been started. This assumes that the tilt motor's power is tied exclusively with the 
rest of the robot.


Author Maxwell Svetlik

"""

import rospy
import roslaunch
import rospkg
from std_msgs.msg import Int16, Float64
from sensor_msgs.msg import JointState
import time

TOLERANCE = 0.005
init_param = "/tilt_motor/encoders_initialized"

class LaunchTiltMotor(object):

    def cb_limit_switch(self, data):
        self.switch_pressed = bool(data.data)
        
    def cb_joint_states(self, data):
        if len(data.position) > 0:
            self.joint_states = data

    def __init__(self):
        self.switch_pressed = False
        self.joint_states = JointState()
        
        if rospy.has_param(init_param):
            has_been_initialized = rospy.get_param(init_param)
            rospy.loginfo("Tilt motor has been previously initialized.")
        else:
            has_been_initialized = False

        rospy.init_node('launch_tilt_motor', anonymous=True)
        rospy.Subscriber("/pillar/limit_switch", Int16, self.cb_limit_switch)
        rospy.Subscriber("/tilt_motor/joint_states", JointState, self.cb_joint_states)
        self.tilt_pub   = rospy.Publisher('/tilt_motor/position_controller/command', Float64, queue_size=1)

        rospack = rospkg.RosPack()
        
        # Setup roslaunch for tilt motor
        launch_file_name_tilt_control = "/launch/tilt_control.launch"

        tilt_control_uuid = roslaunch.rlutil.get_or_generate_uuid(None, False)
        roslaunch.configure_logging(tilt_control_uuid)
        launch = roslaunch.parent.ROSLaunchParent(tilt_control_uuid, [rospack.get_path('poli_pan_tilt')+launch_file_name_tilt_control])
        launch.start()
        
        # wait for EPOS driver to start
        tilt_encoder = 0.0
        if not has_been_initialized:
            while not has_been_initialized and not rospy.is_shutdown():
                rospy.logwarn_throttle(5, "Waiting for tilt motor joint state to be initialized...")
                rospy.sleep(0.1)
                if len(self.joint_states.position) > 0:
                    tilt_encoder = self.joint_states.position[0]
                    has_been_initialized = True
        
        t_end = time.time() + 3 # Cut out auto initialization after 3 seconds
        while time.time() < t_end:
            if (self.joint_states.position[0] <= TOLERANCE and self.joint_states.position[0] >= -TOLERANCE and self.switch_pressed):
                tilt_encoder = self.joint_states.position[0]
                break
            
            msg = Float64()
            msg.data = self.joint_states.position[0] + 0.03
            self.tilt_pub.publish(msg)

        if rospy.is_shutdown():
            return

        if has_been_initialized and (tilt_encoder <= TOLERANCE and tilt_encoder >= -TOLERANCE and self.switch_pressed):
            #life is good
            rospy.set_param(init_param, "true")
            rospy.loginfo("Tilt motor in good state. Continuing to run.")

            # Setup roslaunch for post-initialization movement script
            launch_file_name_initscript = "/launch/torso/post_initialization_movement.launch"
            post_initialization_uuid = roslaunch.rlutil.get_or_generate_uuid(None, False)
            roslaunch.configure_logging(post_initialization_uuid)
            post_initialization_launch = roslaunch.parent.ROSLaunchParent(post_initialization_uuid, [rospack.get_path('poli2_launch')+launch_file_name_initscript])
            post_initialization_launch.start()
            
            while not rospy.is_shutdown():
                rospy.spin()
        else:
            #tilt motor not within spec
            rospy.logerr("Tilt motor does not have correctly initialized encoders.")
            rospy.logerr("Please tilt the head down, disconnect tilt motor power and reconnect.")
            launch.shutdown()
            if rospy.has_param(init_param):
                rospy.delete_param(init_param)

if __name__ == '__main__':
    ltm = LaunchTiltMotor()