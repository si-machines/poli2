#!/usr/bin/env python

"""
This is a high level driver for the EPOS tilt controller for the PoliV2 platform.
This file also launches a script that moves the pan/tilt/pillar/led systems for visual inspection.

The specific purpose of this driver is to ensure that the tilt motor's position encoders 
have been initialized properly. The encoders are set on power-on to the motor.

This driver checks if the tilt LIMIT SWITCH is pressed.
If so, it launches the tilt driver and checks the reported position of its encoders.
If its position value reports 0.0 +/- TOLERANCE the driver is kept alive.
If its out of TOLERANCE the driver is killed, error messages are logged, and this driver exits.

There is a persistance parameter INIT_PARAM that is used to track if this driver has been run since 
the robot has been started. This assumes that the tilt motor's power is tied exclusively with the 
rest of the robot.


Author Maxwell Svetlik

"""

import rospy
import roslaunch
import rospkg
from std_msgs.msg import Int16
from sensor_msgs.msg import JointState

TOLERANCE = 0.005
init_param = "/tilt_motor/encoders_initialized"


def switch_callback(data):
	global switch_pressed
	switch_pressed = bool(data.data)
    
def js_callback(data):
	global joint_states
	if len(data.position) > 0:
		joint_states = data


if __name__ == '__main__':
	global switch_pressed, joint_states
	switch_pressed = False
	joint_states = JointState()
	
	if rospy.has_param(init_param):
		has_been_initialized = rospy.get_param(init_param)
		rospy.loginfo("Tilt motor has been previously initialized.")
	else:
		has_been_initialized = False

	rospy.init_node('tilt_motor_launcher', anonymous=True)
	rospy.Subscriber("/pillar/limit_switch", Int16, switch_callback)
	rospy.Subscriber("/tilt_motor/joint_states", JointState, js_callback)

	r_pack = rospkg.RosPack()
	launch_path = r_pack.get_path('poli_pan_tilt')
	launch_path_initscript = r_pack.get_path('poli_launch')
	launch_file_name = "/launch/tilt_control.launch"
	launch_file_name_initscript = "/launch/post_initialization_movement.launch"
	# Setup roslaunch for tilt motor
	uuid = roslaunch.rlutil.get_or_generate_uuid(None, False)
	roslaunch.configure_logging(uuid)
	launch = roslaunch.parent.ROSLaunchParent(uuid, [launch_path+launch_file_name])


	# Setup roslaunch for post-initialization movement script
	mvmt_uuid = roslaunch.rlutil.get_or_generate_uuid(None, False)
	roslaunch.configure_logging(mvmt_uuid)
	mvmt_launch = roslaunch.parent.ROSLaunchParent(uuid, [launch_path_initscript+launch_file_name_initscript])

	launch.start()
	
	# wait for EPOS driver to start
	tilt_encoder = 0.0
	if not has_been_initialized:
		rospy.sleep(10.0)
		tilt_encoder = joint_states.position[0]
	
	if has_been_initialized or (tilt_encoder <= TOLERANCE and tilt_encoder >= -TOLERANCE and switch_pressed):
		#life is good
		rospy.set_param(init_param, "true")
		rospy.loginfo("Tilt motor in good state. Continuing to run.")
		mvmt_launch.start()
		while not rospy.is_shutdown():
			rospy.spin()
	else:
		#tilt motor not within spec
		rospy.logerr("Tilt motor does not have correctly initialized encoders.")
		rospy.logerr("Please tilt the head down, disconnect tilt motor power and reconnect.")
		launch.shutdown()
		if rospy.has_param(init_param):
		    rospy.delete_param(init_param)

	exit(1)
